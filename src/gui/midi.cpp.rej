--- src/gui/midi.cpp	12 Dec 2007 19:18:39 -0000	1.21
+++ src/gui/midi.cpp	6 Jan 2008 23:20:25 -0000
@@ -28,8 +28,14 @@
 #include "pic.h"
 #include "hardware.h"
 
+#include "midi.h"
+
 #define SYSEX_SIZE 1024
-#define RAWBUF	1024
+
+INLINE void MIDI_InputMsg(Bit8u msg[4]);
+INLINE Bits MIDI_InputSysex(Bit8u *sysex,Bitu len,bool abort);
+
+static Bit8u MIDI_InSysexBuf[SYSEX_SIZE];
 
 Bit8u MIDI_evt_len[256] = {
   0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,  // 0x00
@@ -64,7 +70,9 @@
 		next=handler_list;
 		handler_list=this;
 	};
-	virtual bool Open(const char * /*conf*/) { return true; };
+
+	virtual bool Open(const char * conf) { return true; };
+	virtual bool OpenInput(const char * inconf) {return false;};
 	virtual void Close(void) {};
 	virtual void PlayMsg(Bit8u * /*msg*/) {};
 	virtual void PlaySysex(Bit8u * /*sysex*/,Bitu /*len*/) {};
@@ -99,54 +107,125 @@
 #endif
 
 static struct {
-	Bitu status;
-	Bitu cmd_len;
-	Bitu cmd_pos;
-	Bit8u cmd_buf[8];
+		Bitu status[MIDI_DEVS];
+		Bitu cmd_r;
+	struct {
+		Bitu len;
+		Bitu pos;
+		Bit8u buf[8];
+	} cmd[MIDI_DEVS];
 	struct {
 		Bit8u buf[SYSEX_SIZE];
 		Bitu used;
-	} sysex;
+	} sysex[MIDI_DEVS];
 	bool available;
+	bool in_available;
 	MidiHandler * handler;
+	MidiHandler * in_handler;
+	bool realtime;
+	Bitu inputdev;
+	bool autoinput;
+	bool thruchan;
+	bool clockout;
 } midi;
 
-void MIDI_RawOutByte(Bit8u data) {
+void MIDI_RawOutRTByte(Bit8u data) {
+	if (!midi.realtime) return;
+	if (!midi.clockout && data == 0xf8) return;
+	midi.cmd_r=data<<24;
+	midi.handler->PlayMsg((Bit8u*)&midi.cmd_r);
+}
+
+void MIDI_RawOutThruRTByte(Bit8u data) {
+	if (midi.thruchan) MIDI_RawOutRTByte(data);
+}
+
+void MIDI_RawOutByte(Bit8u data, Bit8u slot) {
+
 	/* Test for a active sysex tranfer */
-	if (midi.status==0xf0) {
+	if (midi.status[slot]==0xf0) {
 		if (!(data&0x80)) { 
-			if (midi.sysex.used<(SYSEX_SIZE-1)) midi.sysex.buf[midi.sysex.used++]=data;
+			if (midi.sysex[slot].used<(SYSEX_SIZE-1)) midi.sysex[slot].buf[midi.sysex[slot].used++]=data;
 			return;
 		} else {
-			midi.sysex.buf[midi.sysex.used++]=0xf7;
-			midi.handler->PlaySysex(midi.sysex.buf,midi.sysex.used);
-			LOG(LOG_ALL,LOG_NORMAL)("Sysex message size %d",midi.sysex.used);
+			midi.sysex[slot].buf[midi.sysex[slot].used++]=0xf7;
+			midi.handler->PlaySysex(midi.sysex[slot].buf,midi.sysex[slot].used);
+			LOG(LOG_ALL,LOG_NORMAL)("Sysex message size %d",midi.sysex[slot].used);
 			if (CaptureState & CAPTURE_MIDI) {
-				CAPTURE_AddMidi( true, midi.sysex.used-1, &midi.sysex.buf[1]);
+				/* don't capture from MIDI passthrough channel */
+				if (slot!=MOUT_THRU) CAPTURE_AddMidi( true, midi.sysex[slot].used-1, &midi.sysex[slot].buf[1]);
 			}
 		}
 	}
 	if (data&0x80) {
-		midi.status=data;
-		midi.cmd_pos=0;
-		midi.cmd_len=MIDI_evt_len[data];
-		if (midi.status==0xf0) {
-			midi.sysex.buf[0]=0xf0;
-			midi.sysex.used=1;
+		midi.status[slot]=data;
+		midi.cmd[slot].pos=0;
+		midi.cmd[slot].len=MIDI_evt_len[data];
+		if (midi.status[slot]==0xf0) {
+			midi.sysex[slot].buf[0]=0xf0;
+			midi.sysex[slot].used=1;
 		}
 	}
-	if (midi.cmd_len) {
-		midi.cmd_buf[midi.cmd_pos++]=data;
-		if (midi.cmd_pos >= midi.cmd_len) {
+	if (midi.cmd[slot].len) {
+		midi.cmd[slot].buf[midi.cmd[slot].pos++]=data;
+		if (midi.cmd[slot].pos >= midi.cmd[slot].len) {
 			if (CaptureState & CAPTURE_MIDI) {
-				CAPTURE_AddMidi(false, midi.cmd_len, midi.cmd_buf);
+				if (slot!=MOUT_THRU) CAPTURE_AddMidi(false, midi.cmd[slot].len, midi.cmd[slot].buf);
 			}
-			midi.handler->PlayMsg(midi.cmd_buf);
-			midi.cmd_pos=1;		//Use Running status
+			if (midi.thruchan || slot!=MOUT_THRU) midi.handler->PlayMsg(midi.cmd[slot].buf);
+			midi.cmd[slot].pos=1;		//Use Running status
 		}
 	}
 }
 
+//allow devices to catch input in autodetection mode
+Bit32s MIDI_ToggleInputDevice(Bit32u device,bool status) {
+	if (!midi.autoinput) return -1;
+	if (midi.inputdev == device) {
+		if (status==false) {
+			midi.inputdev = MDEV_NONE;
+			return 2;
+		}
+		return 1;
+	}
+	midi.inputdev = device;
+	return 0;
+}
+
+INLINE void MIDI_InputMsg(Bit8u msg[4]) {
+	switch (midi.inputdev) {
+		case MDEV_MPU:
+			MPU401_InputMsg(msg);
+			break;
+		case MDEV_SBUART:
+			SB_UART_InputMsg(msg);
+			break;
+		case MDEV_GUS:
+			GUS_UART_InputMsg(msg);
+			break;
+	}
+}
+
+INLINE Bits MIDI_InputSysex(Bit8u *sysex,Bitu len, bool abort) {
+	switch (midi.inputdev) {
+		case MDEV_MPU:
+			return MPU401_InputSysex(sysex,len,abort);
+		case MDEV_SBUART:
+			return SB_UART_InputSysex(sysex,len,abort);
+		case MDEV_GUS:
+			return GUS_UART_InputSysex(sysex,len,abort);
+		default:
+			return 0;
+	}
+}
+
+void MIDI_ClearBuffer(Bit8u slot) {
+	midi.sysex[slot].used=0;
+	midi.status[slot]=0x00;
+	midi.cmd[slot].pos=0;
+	midi.cmd[slot].len=0;
+}
+
 bool MIDI_Available(void)  {
 	return midi.available;
 }
@@ -155,26 +234,87 @@
 public:
 	MIDI(Section* configuration):Module_base(configuration){
 		Section_prop * section=static_cast<Section_prop *>(configuration);
-		const char * dev=section->Get_string("device");
+		char * dev = "";
+		char * sel_indevice = 0;
+		const char * dev_list=section->Get_string("device");
 		const char * conf=section->Get_string("config");
+		const char * inconf=section->Get_string("inconfig");
+		char * mflags=(char*)section->Get_string("midioptions");
+
+		midi.realtime = true;
+		midi.inputdev = MDEV_MPU;
+		midi.autoinput = true;
+		midi.thruchan = false;
+		midi.clockout = false;
+
+		std::string devstr;
+		std::string indevstr;
+
+		while (dev_list!=NULL) {
+			char * devtoken = strtok((char*)dev_list,",");
+			if (devtoken==NULL) break;
+			devstr = devtoken;
+			devstr = devstr.erase(devstr.find_last_not_of(" ")+1);
+			devstr = devstr.erase(0,devstr.find_first_not_of(" "));
+			dev = (char*)devstr.c_str();
+
+			devtoken = strtok(NULL,",");
+			if (devtoken==NULL) break;
+			indevstr = devtoken;
+			indevstr = indevstr.erase(indevstr.find_last_not_of(" ")+1);
+			indevstr = indevstr.erase(0,indevstr.find_first_not_of(" "));
+			sel_indevice = (char*)indevstr.c_str();
+			break;
+		}
+
+		if (mflags!=NULL) {
+			char * mflagtoken = strtok(mflags,",");
+			while (mflagtoken!=NULL) {
+				std::string flag(mflagtoken);
+				flag = flag.erase(flag.find_last_not_of(" ")+1);
+				flag = flag.erase(0,flag.find_first_not_of(" "));
+				const char * flag_w = flag.c_str();
+
+				//input to internal device options
+				if (!strcasecmp(flag_w,"autoinput")) midi.autoinput=true;
+				if (!strcasecmp(flag_w,"inputmpu401")) {midi.inputdev = MDEV_MPU;midi.autoinput=false;}
+				if (!strcasecmp(flag_w,"inputsbuart")) {midi.inputdev = MDEV_SBUART;midi.autoinput=false;}
+				if (!strcasecmp(flag_w,"inputgus")) {midi.inputdev = MDEV_GUS;midi.autoinput=false;}
+
+				if (!strcasecmp(flag_w,"norealtime")) midi.realtime = false;
+				if (!strcasecmp(flag_w,"passthrough")) midi.thruchan = true;
+				if (!strcasecmp(flag_w,"clockout")) midi.clockout = true;
+				if (!strcasecmp(flag_w,"throttle")) MPU401_SetupTxHandler();
+				//TODO:add remaining options
+				mflagtoken = strtok(NULL,",");
+			}
+		}
+
 		/* If device = "default" go for first handler that works */
 		MidiHandler * handler;
 //		MAPPER_AddHandler(MIDI_SaveRawEvent,MK_f8,MMOD1|MMOD2,"caprawmidi","Cap MIDI");
-		midi.status=0x00;
-		midi.cmd_pos=0;
-		midi.cmd_len=0;
+		for (Bitu slot=0;slot<MIDI_DEVS;slot++) {
+			midi.status[slot]=0x00;
+			midi.cmd[slot].pos=0;
+			midi.cmd[slot].len=0;
+			midi.sysex[slot].used=0;
+		}
+		if (!strcasecmp(dev,"none")) {
+			if (sel_indevice) goto midiin;
+			else return;
+		}
 		if (!strcasecmp(dev,"default")) goto getdefault;
 		handler=handler_list;
 		while (handler) {
 			if (!strcasecmp(dev,handler->GetName())) {
 				if (!handler->Open(conf)) {
-					LOG_MSG("MIDI:Can't open device:%s with config:%s.",dev,conf);	
+					LOG_MSG("MIDI:Can't open device:%s with config:%s.",dev,conf);
 					goto getdefault;
 				}
 				midi.handler=handler;
 				midi.available=true;	
 				LOG_MSG("MIDI:Opened device:%s",handler->GetName());
-				return;
+				goto midiin;
 			}
 			handler=handler->next;
 		}
@@ -186,16 +326,62 @@
 				midi.available=true;	
 				midi.handler=handler;
 				LOG_MSG("MIDI:Opened device:%s",handler->GetName());
-				return;
+				goto midiin;
 			}
 			handler=handler->next;
 		}
-		/* This shouldn't be possible */
-	}
+midiin:
+		if (sel_indevice && !strcasecmp(sel_indevice,"none")) return;
+		if (strcasecmp(inconf,"none")) {
+			if ((sel_indevice) && strcasecmp(sel_indevice,"")) {
+				MidiHandler * sel_handler=handler_list;
+				while (sel_handler) {
+					if (!strcasecmp(sel_indevice,sel_handler->GetName())) {
+						if (sel_handler->OpenInput(inconf)) {
+							LOG_MSG("MIDI:Opened input device:%s.",sel_handler->GetName());
+							midi.in_available=true;
+							midi.in_handler=sel_handler;
+						}
+						else LOG_MSG("MIDI:Can't open input device:%s.",sel_handler->GetName());
+						return;
+					}
+					sel_handler=sel_handler->next;
+				}
+				LOG_MSG("MIDI:Can't find input device:%s.",sel_handler->GetName());
+				return;
+			}
+			//first try to open same handler
+			MidiHandler * output_handler=0;
+			if (midi.available) {
+					output_handler=handler;
+					if (handler->OpenInput(inconf)) {
+						LOG_MSG("MIDI:Opened input device:%s.",handler->GetName());
+						midi.in_available=true;
+						midi.in_handler=handler;
+						return;
+					}
+			}
+			handler=handler_list;
+			while (handler) {
+				if (output_handler!=handler)
+					if (handler->OpenInput(inconf)) {
+						LOG_MSG("MIDI:Opened input device:%s.",handler->GetName());
+						midi.in_available=true;
+						midi.in_handler=handler;
+						return;
+					}
+				handler=handler->next;
+			}
+		}	
+	};
+
 	~MIDI(){
+		if (midi.in_available && midi.in_handler!=midi.handler) midi.in_handler->Close();
 		if(midi.available) midi.handler->Close();
 		midi.available = false;
+		midi.in_available = false;
 		midi.handler = 0;
+		midi.in_handler = 0;
 	}
 };
 
