--- src/gui/midi_win32.h	14 Jun 2007 08:23:46 -0000	1.14
+++ src/gui/midi_win32.h	6 Jan 2008 23:20:26 -0000
@@ -26,14 +26,60 @@
 #include <string>
 #include <sstream>
 
+void CALLBACK Win32_midiInCallback(HMIDIIN hMidiIn, UINT wMsg, DWORD_PTR dwInstance, DWORD_PTR dwParam1, DWORD_PTR dwParam2) {
+	//LOG_MSG("wMsg:%x %x %x",wMsg, dwParam1, dwParam2);
+	Bit8u msg[4] = {(Bit8u(dwParam1&0xff)),(Bit8u((dwParam1&0xff00)>>8)),
+					(Bit8u((dwParam1&0xff0000)>>16)),MIDI_evt_len[(Bit8u(dwParam1&0xff))]};
+	Bit8u *sysex;
+	Bitu len;
+	MIDIHDR *t_hdr;
+	switch (wMsg) {
+		case MM_MIM_DATA:  /* 0x3C3 - midi message */
+			MIDI_InputMsg(msg);
+			break;
+		case MM_MIM_OPEN:  /* 0x3C1 */
+			break;
+		case MM_MIM_CLOSE: /* 0x3C2 */
+			break;
+		case MM_MIM_LONGDATA: /* 0x3C4 - sysex */
+			t_hdr=(MIDIHDR*)dwParam1;
+			sysex=(Bit8u*)t_hdr->lpData; 
+			len=(Bitu)t_hdr->dwBytesRecorded;
+			{
+				Bitu cnt=5;
+				while (cnt) { //abort if timed out
+					Bitu ret = Bitu(MIDI_InputSysex(sysex,len,false));
+					if (!ret) {len=0;break;}
+					if (len==ret) cnt--; else cnt=5;
+					sysex+=len-ret;
+					len=ret;
+					Sleep(5);//msec
+				}
+				if (len) MIDI_InputSysex(sysex,0,false);
+			}
+			midiInUnprepareHeader(hMidiIn,t_hdr,sizeof(*t_hdr));
+			t_hdr->dwBytesRecorded = 0 ;
+			midiInPrepareHeader(hMidiIn,t_hdr,sizeof(*t_hdr));
+			break;
+		case MM_MIM_ERROR:
+		case MM_MIM_LONGERROR:
+			break;
+		default:
+			LOG(LOG_MISC, LOG_NORMAL) ("MIDI: Unhandled input type %x",wMsg);
+	}
+};
+
 class MidiHandler_win32: public MidiHandler {
 private:
 	HMIDIOUT m_out;
+	HMIDIIN m_in;
 	MIDIHDR m_hdr;
+	MIDIHDR m_inhdr;
 	HANDLE m_event;
 	bool isOpen;
+	bool isOpenInput;
 public:
-	MidiHandler_win32() : isOpen(false),MidiHandler() {};
+	MidiHandler_win32() : isOpen(false),isOpenInput(false),MidiHandler() {};
 	const char * GetName(void) { return "win32";};
 	bool Open(const char * conf) {
 		if (isOpen) return false;
@@ -121,9 +201,7 @@
 			SetEvent (m_event);
 			return;
 		}
-	}
+	};
 };
 
 MidiHandler_win32 Midi_win32; 
-
-
